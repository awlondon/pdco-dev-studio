import fs from 'node:fs';
import path from 'node:path';
import express from 'express';

function loadDotEnv() {
  const envPath = path.resolve(process.cwd(), '.env');
  if (!fs.existsSync(envPath)) return;

  const content = fs.readFileSync(envPath, 'utf8');
  for (const rawLine of content.split('\n')) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;
    const eqIndex = line.indexOf('=');
    if (eqIndex === -1) continue;
    const key = line.slice(0, eqIndex).trim();
    const value = line.slice(eqIndex + 1).trim();
    if (key && process.env[key] === undefined) {
      process.env[key] = value;
    }
  }
}

loadDotEnv();

const app = express();
app.use(express.json({ limit: '1mb' }));

const REQUIRED_ENV = ['GITHUB_TOKEN', 'GITHUB_OWNER'];
const missingEnv = REQUIRED_ENV.filter((name) => !process.env[name]);
if (missingEnv.length) {
  throw new Error(`Missing required environment variables: ${missingEnv.join(', ')}`);
}

const OWNER = process.env.GITHUB_OWNER;
const TOKEN = process.env.GITHUB_TOKEN;
const PORT = Number(process.env.PORT || 3000);
const TASK_LIMIT = Number(process.env.REPO_TASK_LIMIT || 15);
const OBJECTIVE_LENGTH_LIMIT = Number(process.env.OBJECTIVE_MAX_LENGTH || 120);
const COST_THRESHOLD = Number(process.env.COST_THRESHOLD || 100);
const API_URL = 'https://api.github.com';

function sanitizeRepoName(objective) {
  return objective
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '')
    .replace(/--+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 50);
}

function estimateCost(tasks) {
  return tasks.reduce((total, task) => {
    const complexity = typeof task?.complexity === 'number' ? task.complexity : 1;
    return total + complexity;
  }, 0);
}

function buildScaffoldFiles(objective, tasks) {
  const hasReact = tasks.some((task) => task?.type === 'react');
  const hasFrontend = tasks.some((task) => task?.type === 'frontend');
  const hasApi = tasks.some((task) => task?.type === 'api');
  const hasDocs = tasks.some((task) => task?.type === 'docs');

  const escapedObjective = objective.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  const taskItems = tasks
    .map((task) => `<li>${String(task?.description || 'Untitled task')}</li>`)
    .join('\n');

  const files = [];

  if (hasReact) {
    files.push({
      path: 'README.md',
      message: 'Add React scaffold instructions',
      content: `# ${objective}\n\nThis repository was generated from a task graph.\n\n## Getting started\n\n\`\`\`bash\nnpm create vite@latest . -- --template react\nnpm install\nnpm run dev\n\`\`\`\n`,
    });
  }

  if (hasFrontend || !hasApi) {
    files.push({
      path: 'index.html',
      message: 'Add landing page',
      content: `<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>${escapedObjective}</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <h1>${escapedObjective}</h1>
  <section>
    <h2>Generated Tasks</h2>
    <ul>
      ${taskItems}
    </ul>
  </section>
</body>
</html>
`,
    });

    files.push({
      path: 'styles.css',
      message: 'Add basic styles',
      content: `body { font-family: sans-serif; padding: 40px; }
h1 { font-size: 42px; }
section { margin-bottom: 40px; }
`,
    });
  }

  if (hasApi) {
    files.push({
      path: 'server.js',
      message: 'Add API starter',
      content: `import express from 'express';

const app = express();
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ status: 'ok' });
});

app.listen(3000, () => {
  console.log('API server on :3000');
});
`,
    });
  }

  if (hasDocs || files.length === 0) {
    files.push({
      path: 'README.md',
      message: 'Add project README',
      content: `# ${objective}\n\nGenerated by the Task Graph Repo Generator.\n`,
    });
  }

  return files;
}

async function githubRequest(method, endpoint, body) {
  const response = await fetch(`${API_URL}${endpoint}`, {
    method,
    headers: {
      Authorization: `Bearer ${TOKEN}`,
      Accept: 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28',
      'Content-Type': 'application/json',
      'User-Agent': 'repo-generator-service',
    },
    body: body ? JSON.stringify(body) : undefined,
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`GitHub API ${method} ${endpoint} failed (${response.status}): ${errorText}`);
  }

  if (response.status === 204) return {};
  return response.json();
}

async function commitFile(repo, filePath, content, message) {
  const encoded = Buffer.from(content).toString('base64');
  await githubRequest('PUT', `/repos/${OWNER}/${repo}/contents/${filePath}`, {
    message,
    content: encoded,
  });
}

async function createRepo(repoName) {
  await githubRequest('POST', '/user/repos', {
    name: repoName,
    private: false,
    auto_init: true,
  });
}

async function enablePages(repoName) {
  await githubRequest('POST', `/repos/${OWNER}/${repoName}/pages`, {
    source: {
      branch: 'main',
      path: '/',
    },
  });
}

function validatePayload(payload) {
  const objective = typeof payload?.objective === 'string' ? payload.objective.trim() : '';
  const tasks = Array.isArray(payload?.tasks) ? payload.tasks : [];

  if (!objective) {
    return { status: 400, error: 'objective is required' };
  }

  if (!tasks.length) {
    return { status: 400, error: 'tasks must be a non-empty array' };
  }

  if (tasks.length > TASK_LIMIT && payload?.confirmLargeTaskRun !== true) {
    return {
      status: 409,
      error: `Task count (${tasks.length}) exceeds limit (${TASK_LIMIT}). Confirm by setting confirmLargeTaskRun=true.`,
    };
  }

  const compressedObjective =
    objective.length > OBJECTIVE_LENGTH_LIMIT
      ? `${objective.slice(0, OBJECTIVE_LENGTH_LIMIT - 1).trimEnd()}â€¦`
      : objective;

  const estimatedCost = estimateCost(tasks);
  const shouldDowngradeModel = estimatedCost > COST_THRESHOLD;

  return {
    objective: compressedObjective,
    tasks,
    estimatedCost,
    shouldDowngradeModel,
  };
}

app.post('/generate-repo', async (req, res) => {
  const validated = validatePayload(req.body);
  if (validated.error) {
    return res.status(validated.status).json({ error: validated.error });
  }

  const { objective, tasks, estimatedCost, shouldDowngradeModel } = validated;
  const repoName = sanitizeRepoName(objective);

  if (!repoName) {
    return res.status(400).json({ error: 'Unable to generate a valid repository name from objective.' });
  }

  try {
    await createRepo(repoName);
    const scaffoldFiles = buildScaffoldFiles(objective, tasks);
    for (const file of scaffoldFiles) {
      await commitFile(repoName, file.path, file.content, file.message);
    }
    await enablePages(repoName);

    const liveURL = `https://${OWNER}.github.io/${repoName}/`;
    return res.json({
      status: 'success',
      repo: repoName,
      live_url: liveURL,
      estimated_cost: estimatedCost,
      model_tier: shouldDowngradeModel ? 'standard' : 'premium',
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: error.message });
  }
});

app.listen(PORT, () => {
  console.log(`Repo Generator running on port ${PORT}`);
});
